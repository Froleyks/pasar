#pragma once

extern "C" {
#include "sat/ipasir.h"
}

#include "src/problem/problem.hpp"
#include "tools/logger.hpp"
#include <limits>

// this capsules the ipasir interface
// clauses added will be added to all past and future steps
class Formula {
private:
  bool withSolver;
  void *solver;
  int numBaseVariables     = 0;
  size_t new_clauses_begin = 0;
  int currentStep          = -1;
  // makestep x variable x value
  size_t initialClausesIndex = 0;

  struct Variable {
    bool isEnd;
    bool polarity;
    bool isState;
    size_t t;
    action_t i;
    value_t v;
    Variable(bool isEnd = true, bool polarity = false, bool isState = false,
             size_t t = 0, action_t i = 0, value_t v = 0)
        : isEnd(isEnd), polarity(polarity), isState(isState), t(t), i(i), v(v) {
    }
  };

  std::vector<Variable> clauses;
  Assignment assumptions;

  void activateAssumptions() {
    for (auto [variable, value] : assumptions) {
      ipasir_assume(solver, state.back()[variable][value]);
    }
  }

  void add(Variable &v) {
    int lit = 0;
    if (!v.isEnd) {
      if (v.isState) {
        lit = state[v.t][v.i][v.v];
      } else {
        lit = action[v.t][v.i];
      }
      if (!v.polarity) {
        lit = -lit;
      }
    }
    ipasir_add(solver, lit);
  }

  void addClausesForNewStep() {
    for (size_t i = 0; i < clauses.size(); ++i) {
      clauses[i].t++;

      add(clauses[i]);
    }
  }

  // only new clauses
  // known clauses are added in increase makespan
  void addClausesForAllSteps() {
    if (new_clauses_begin == clauses.size()) {
      return;
    }
    std::vector<Variable> new_clauses(clauses.begin() + new_clauses_begin,
                                      clauses.end());
    new_clauses_begin = clauses.size();
    assert(new_clauses.back().isEnd);
    for (int step = 0; step < currentStep + 1; ++step) {
      for (unsigned i = 0; i < new_clauses.size(); ++i) {
        // std::cout << new_clauses[i] << std::endl;
        add(new_clauses[i]);
        new_clauses[i].t--;
      }
    }
  }

public:
  std::vector<std::vector<std::vector<int>>> state;
  std::vector<std::vector<int>> action;

  Formula(const Problem &problem, bool withSolver = true,
          const std::vector<Variable> &additionalClauses = {})
      : withSolver(withSolver) {
    if (withSolver) {
      solver = ipasir_init();

      // glucose fix
      ipasir_set_learn(solver, NULL, 0, NULL);

      log(3) << "Using the incremental SAT solver" << ipasir_signature();
    }

    // set state variables
    state.emplace_back(problem.numVariables);
    // all finite domain variables
    for (size_t i = 0; i < problem.numValues.size(); ++i) {
      state[0][i].resize(problem.numValues[i]);
      for (int v = 0; v < problem.numValues[i]; ++v) {
        state[0][i][v] = ++numBaseVariables;
      }
    }
    // prepostions
    for (size_t i = problem.numValues.size(); i < problem.numVariables; ++i) {
      // no dual-rail encoding for binary values
      ++numBaseVariables;
      state[0][i] = {numBaseVariables, -numBaseVariables};
    }

    // set action variables
    action.emplace_back(problem.numActions);
    for (size_t i = 0; i < action[0].size(); ++i) {
      action[0][i] = ++numBaseVariables;
    }

    // TODO the last set of action vars is not needed
    increaseMakespan();

    // at least one value
    // is not necessary for the fixed initial sate
    for (size_t i = 0; i < state[0].size(); ++i) {
      if (state[0][i].size() > 2) {
        for (size_t v = 0; v < state[0][i].size(); ++v) {
          addS(i, v, true, true);
        }
        close();
      }
    }

    // mutex which are generated by sas transform of fastdownward
    for (const auto &mutex : problem.mutexes) {
      for (size_t i = 0; i < mutex.size() - 1; ++i) {
        for (size_t j = i + 1; j < mutex.size(); ++j) {
          addS(mutex[i].first, mutex[i].second, false, true);
          addS(mutex[j].first, mutex[j].second, false, true);
          close();
        }
      }
    }
    initialClausesIndex = clauses.size();
    clauses.insert(clauses.begin(), additionalClauses.begin(),
                   additionalClauses.end());
  }

  ~Formula() {
    if (withSolver) {
      ipasir_release(solver);
    }
  }

  unsigned getMakespan() { return currentStep + 1; }

  unsigned increaseMakespan(unsigned steps = 1) {
    for (unsigned i = 0; i < steps; ++i) {
      // set state variables
      state.push_back(state.back());
      for (size_t i = 0; i < state.back().size(); ++i) {
        for (size_t v = 0; v < state.back()[i].size(); ++v) {
          if (state.back()[i][v] > 0) {
            state.back()[i][v] += numBaseVariables;
          } else {
            state.back()[i][v] -= numBaseVariables;
          }
        }
      }

      // set action variables
      action.push_back(action.back());
      for (size_t i = 0; i < action.back().size(); ++i) {
        action.back()[i] += numBaseVariables;
      }

      addClausesForNewStep();

      currentStep++;
    }

    return currentStep + 1;
  }

  // assuming the goal
  inline void assumeAtLast(int variable, unsigned value) {
    assumptions.emplace_back(variable, value);
  }

  inline void addInitialStateAtom(int variable, unsigned value,
                                  bool polarity = true) {
    // std::cout << (polarity ? 1 : -1) * state[0][variable][value] <<
    // std::endl; std::cout << "0" << std::endl;

    ipasir_add(solver, (polarity ? 1 : -1) * state[0][variable][value]);

    ipasir_add(solver, 0);
  }

  // clauses added will be added to all past and future steps
  inline void addS(int variable, unsigned value, bool polarity = true,
                   bool next = false) {

    if (next) {
      // clauses.push_back((polarity ? 1 : -1) *
      //                   state[currentStep + 1][variable][value]);
      clauses.emplace_back(false, polarity, true, currentStep + 1, variable,
                           value);
    } else {
      // clauses.push_back((polarity ? 1 : -1) *
      //                   state[currentStep][variable][value]);
      clauses.emplace_back(false, polarity, true, currentStep, variable, value);
    }
  }

  inline void addA(int index, bool polarity = true, bool next = false) {
    if (next) {
      // clauses.push_back((polarity ? 1 : -1) * action[currentStep +
      // 1][index]);
      clauses.emplace_back(false, polarity, false, currentStep + 1, index);
    } else {
      // clauses.push_back((polarity ? 1 : -1) * action[currentStep][index]);
      clauses.emplace_back(false, polarity, false, currentStep, index);
    }
  }

  inline void close() { clauses.emplace_back(); }

  // assume goal and try to solve
  bool solve(double timeLimit = std::numeric_limits<double>::infinity()) {
    log(5) << "start sat solver";
    addClausesForAllSteps();
    activateAssumptions();
    double endTime = Logger::getTime() + timeLimit;
    ipasir_set_terminate(solver, &endTime, [](void *endTime) {
      return (int)(Logger::getTime() > *(double *)(endTime));
    });
    int satRes = ipasir_solve(solver);
    for (int i = 0; i < action.back().back(); ++i) {
      if (ipasir_val(solver, i) > 0) {
        // std::cout << ipasir_val(solver, i) << " ";
      }
    }
    return satRes == 10;
  }

  int getStateValue(variable_t variable, size_t t) const {
    for (unsigned i = 0; i < state[t][variable].size(); ++i) {
      int lit = state[t][variable][i];
      if (lit > 0) {
        // TODO not important values
        if (ipasir_val(solver, lit) >= 0) {
          return i;
        }
      } else {
        if (ipasir_val(solver, -lit) <= 0) {
          return i;
        }
      }
    }
    assert(false);
    return -1;
  }

  bool getActionValue(unsigned index, unsigned t) const {
    // not important variables should be false, a minimum of actions is
    // preferred
    return ipasir_val(solver, action[t][index]) > 0;
  }

  void getClauses(std::vector<Variable> &c) {
    c = std::vector<Variable>(clauses.begin() + initialClausesIndex,
                              clauses.end());
  }
};
